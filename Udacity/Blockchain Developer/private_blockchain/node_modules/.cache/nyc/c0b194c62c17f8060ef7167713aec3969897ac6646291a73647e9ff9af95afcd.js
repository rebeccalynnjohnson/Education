var cov_1y52old2s1=function(){var path="/Users/Picchu/Documents/private_blockchain/src/block.js";var hash="82a2cda3b86d307c73e01864d8ee246496f76828";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"/Users/Picchu/Documents/private_blockchain/src/block.js",statementMap:{"0":{start:{line:12,column:15},end:{line:12,column:42}},"1":{start:{line:13,column:18},end:{line:13,column:38}},"2":{start:{line:19,column:2},end:{line:19,column:19}},"3":{start:{line:20,column:2},end:{line:20,column:18}},"4":{start:{line:21,column:2},end:{line:21,column:64}},"5":{start:{line:22,column:2},end:{line:22,column:16}},"6":{start:{line:23,column:2},end:{line:23,column:32}},"7":{start:{line:39,column:19},end:{line:39,column:23}},"8":{start:{line:40,column:8},end:{line:64,column:11}},"9":{start:{line:43,column:32},end:{line:43,column:41}},"10":{start:{line:46,column:12},end:{line:46,column:29}},"11":{start:{line:49,column:28},end:{line:49,column:67}},"12":{start:{line:52,column:12},end:{line:52,column:38}},"13":{start:{line:55,column:12},end:{line:63,column:13}},"14":{start:{line:58,column:14},end:{line:58,column:44}},"15":{start:{line:62,column:14},end:{line:62,column:47}},"16":{start:{line:81,column:19},end:{line:81,column:23}},"17":{start:{line:82,column:8},end:{line:98,column:11}},"18":{start:{line:85,column:33},end:{line:85,column:42}},"19":{start:{line:89,column:34},end:{line:89,column:84}},"20":{start:{line:92,column:10},end:{line:95,column:11}},"21":{start:{line:94,column:12},end:{line:94,column:38}},"22":{start:{line:104,column:0},end:{line:104,column:29}}},fnMap:{"0":{name:"(anonymous_0)",decl:{start:{line:18,column:1},end:{line:18,column:2}},loc:{start:{line:18,column:18},end:{line:24,column:5}},line:18},"1":{name:"(anonymous_1)",decl:{start:{line:38,column:4},end:{line:38,column:5}},loc:{start:{line:38,column:15},end:{line:65,column:5}},line:38},"2":{name:"(anonymous_2)",decl:{start:{line:40,column:27},end:{line:40,column:28}},loc:{start:{line:40,column:48},end:{line:64,column:9}},line:40},"3":{name:"(anonymous_3)",decl:{start:{line:76,column:4},end:{line:76,column:5}},loc:{start:{line:76,column:15},end:{line:100,column:5}},line:76},"4":{name:"(anonymous_4)",decl:{start:{line:82,column:27},end:{line:82,column:28}},loc:{start:{line:82,column:48},end:{line:98,column:9}},line:82}},branchMap:{"0":{loc:{start:{line:55,column:12},end:{line:63,column:13}},type:"if",locations:[{start:{line:55,column:12},end:{line:63,column:13}},{start:{line:55,column:12},end:{line:63,column:13}}],line:55},"1":{loc:{start:{line:92,column:10},end:{line:95,column:11}},type:"if",locations:[{start:{line:92,column:10},end:{line:95,column:11}},{start:{line:92,column:10},end:{line:95,column:11}}],line:92}},s:{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":0,"13":0,"14":0,"15":0,"16":0,"17":0,"18":0,"19":0,"20":0,"21":0,"22":0},f:{"0":0,"1":0,"2":0,"3":0,"4":0},b:{"0":[0,0],"1":[0,0]},_coverageSchema:"43e27e138ebf9cfc5966b082cf9a028302ed4184",hash:"82a2cda3b86d307c73e01864d8ee246496f76828"};var coverage=global[gcv]||(global[gcv]={});if(coverage[path]&&coverage[path].hash===hash){return coverage[path];}return coverage[path]=coverageData;}();/**
 *                          Block class
 *  The Block class is a main component into any Blockchain platform,
 *  it will store the data and act as a dataset for your application.
 *  The class will expose a method to validate the data... The body of
 *  the block will contain an Object that contain the data to be stored,
 *  the data should be stored encoded.
 *  All the exposed methods should return a Promise to allow all the methods
 *  run asynchronous.
 */const SHA256=(cov_1y52old2s1.s[0]++,require('crypto-js/sha256'));const hex2ascii=(cov_1y52old2s1.s[1]++,require('hex2ascii'));class Block{// Constructor - argument data will be the object containing the transaction data
constructor(data){cov_1y52old2s1.f[0]++;cov_1y52old2s1.s[2]++;this.hash=null;// Hash of the block
cov_1y52old2s1.s[3]++;this.height=0;// Block Height (consecutive number of each block)
cov_1y52old2s1.s[4]++;this.body=Buffer.from(JSON.stringify(data)).toString('hex');// Will contain the transactions stored in the block, by default it will encode the data
cov_1y52old2s1.s[5]++;this.time=0;// Timestamp for the Block creation
cov_1y52old2s1.s[6]++;this.previousBlockHash=null;// Reference to the previous Block Hash
}/**
     *  validate() method will validate if the block has been tampered or not.
     *  Been tampered means that someone from outside the application tried to change
     *  values in the block data as a consecuence the hash of the block should be different.
     *  Steps:
     *  1. Return a new promise to allow the method be called asynchronous.
     *  2. Save the in auxiliary variable the current hash of the block (`this` represent the block object)
     *  3. Recalculate the hash of the entire block (Use SHA256 from crypto-js library)
     *  4. Compare if the auxiliary hash value is different from the calculated one.
     *  5. Resolve true or false depending if it is valid or not.
     *  Note: to access the class values inside a Promise code you need to create an auxiliary value `let self = this;`
     */validate(){cov_1y52old2s1.f[1]++;let self=(cov_1y52old2s1.s[7]++,this);cov_1y52old2s1.s[8]++;return new Promise((resolve,reject)=>{cov_1y52old2s1.f[2]++;// Save in auxiliary variable the current block hash
let auxiliaryHash=(cov_1y52old2s1.s[9]++,self.hash);// Put null in the block has cauz the hash block was calculated with null in the varaible
cov_1y52old2s1.s[10]++;self.hash=null;// Recalculate the hash of the Block
let hashBlock=(cov_1y52old2s1.s[11]++,SHA256(JSON.stringify(self).toString()));// Reevaluate the varaible hash with the hash stored earlier
cov_1y52old2s1.s[12]++;self.hash=auxiliaryHash;// Comparing if the hashes changed
cov_1y52old2s1.s[13]++;if(auxiliaryHash==hashBlock){cov_1y52old2s1.b[0][0]++;cov_1y52old2s1.s[14]++;// Returning the Block is not valid
resolve("The Block is valid");}else{cov_1y52old2s1.b[0][1]++;cov_1y52old2s1.s[15]++;// Returning the Block is valid
reject("The Block is not valid");}});}/**
     *  Auxiliary Method to return the block body (decoding the data)
     *  Steps:
     *
     *  1. Use hex2ascii module to decode the data
     *  2. Because data is a javascript object use JSON.parse(string) to get the Javascript Object
     *  3. Resolve with the data and make sure that you don't need to return the data for the `genesis block`
     *     or Reject with an error.
     */getBData(){cov_1y52old2s1.f[3]++;// Resolve with the data if the object isn't the Genesis block
let self=(cov_1y52old2s1.s[16]++,this);cov_1y52old2s1.s[17]++;return new Promise((resolve,reject)=>{cov_1y52old2s1.f[4]++;// Getting the encoded data saved in the Block
let encodedBlockData=(cov_1y52old2s1.s[18]++,self.body);// Decoding the data to retrieve the JSON representation of the object
// Parse the data to an object to be retrieve.
var decodedBlockData=(cov_1y52old2s1.s[19]++,JSON.parse(hex2ascii(encodedBlockData.toString())));// Skip the Genesis block
cov_1y52old2s1.s[20]++;if(self.height!=0){cov_1y52old2s1.b[1][0]++;cov_1y52old2s1.s[21]++;// Returning the decoded data of the block
resolve(decodedBlockData);}else{cov_1y52old2s1.b[1][1]++;}//reject(null)
});}}cov_1y52old2s1.s[22]++;module.exports.Block=Block;// Exposing the Block class as a module